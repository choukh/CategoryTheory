# Coq范畴论(6.2): 米田引理

> Q群：893531731  
> [GitHub - choukh/CategoryTheory](https://github.com/choukh/CategoryTheory)  
> [总目录](https://zhuanlan.zhihu.com/p/556697215)  

本篇涉及的库中模块:

```Coq
From Category.Instance Require Import Sets.
From Category.Functor Require Import Hom.
From Category.Functor Require Import Hom.Yoneda.
```

米田引理是范畴论中的著名结论, 相关介绍有很多, 我们这里直奔主题.

给定范畴 C, 米田引理是说, 对任意对象 a : C 和函子 F : C ⟶ **Set**, 存在一个关于 a 的特殊函子 (叫做 **Hom函子**) Hom(a, -) : C ⟶ **Set**, 使得从它到 F 的自然变换集与 F a 同构, 也即存在自然变换集 Hom(a, -) ⟹ F 到集合 F a 的双射.

它有一个对偶的形式, 只需把上面的 F : C ⟶ **Set** 换成 F : C^op ⟶ **Set**, 并且把 Hom(a, -) : C ⟶ **Set** 换成 Hom(-, a) : C^op ⟶ **Set**.

形式地, 我们正式引入广集范畴 **Sets**, 作为上面所说的 **Set**. 因为第 [(1)](https://zhuanlan.zhihu.com/p/556697215) 篇说了, 态射集是广集, 而自然变换集是函子范畴中的态射集, 所以它也是广集.

## 广集范畴

我们说一个类型 A 是广集当且仅当存在 A 上的等价关系 equiv.

```Coq
(* Lib/Setoid.v *)

Class Setoid A := {
  equiv : crelation A;
  setoid_equiv : Equivalence equiv
}.
```

广集对象 SetoidObject 封装了载体类型 carrier 以及 "carrier 是广集" 的证据 is_setoid.

```Coq
(* Instance/Sets.v *)

Record SetoidObject := {
  carrier :> Type;
  is_setoid :> Setoid carrier
}.
```

广集对象间的态射 SetoidMorphism 封装了载体类型间的函数 morphism 以及 "equiv 尊重 morphism" 的证据 proper_morphism.

```Coq
Record SetoidMorphism `{Setoid x} `{Setoid y} := {
  morphism :> x -> y;
  proper_morphism :> Proper (equiv ==> equiv) morphism
}.
```

不难证明 SetoidMorphism 也是个广集, 其 equiv 由 morphism 函数的外延给出.

```Coq
Program Instance SetoidMorphism_Setoid {x y : SetoidObject} :
  Setoid (SetoidMorphism x y) := {|
  equiv := fun f g => forall x, @equiv _ y (f x) (g x)
|}.
(* Obligation略 *)
```

SetoidMorphism 的恒等和复合分别是 morphism 的恒等和复合.

```Coq
Definition setoid_morphism_id {x : SetoidObject} : SetoidMorphism x x := {|
  morphism := Datatypes.id
|}.

Program Definition setoid_morphism_compose {x y C : SetoidObject}
        (g : SetoidMorphism y C)
        (f : SetoidMorphism x y) : SetoidMorphism x C := {|
  morphism := Basics.compose g f
|}.
(* Obligation略 *)
```

这样就得到了广集范畴 **Sets**.

```Coq
Program Definition Sets : Category := {|
  obj     := SetoidObject;
  hom     := fun x y => SetoidMorphism x y;
  homset  := @SetoidMorphism_Setoid;
  id      := @setoid_morphism_id;
  compose := @setoid_morphism_compose
|}.
(* Obligation略 *)
```

## Hom函子

Hom函子是对偶的一对, 分别定义如下.

- Hom(a, -) : C ⟶ **Sets**
  - fobj 把对象 x : C 映射为态射集 a ~> x
  - fmap 把态射 f : x ~> y 映射为态射集间的函数 (a ~> x) → (a ~> y), 由 (λ g : a ~> x, f ∘ g) 给出

```Coq
(* Ch17_2.v *)
(* 这里介绍的代码与库中略有不同, 我们对定义做了分拆, 并标注了类型 *)

Program Definition Hom {C : Category} (a : C) : C ⟶ Sets := {|
  fobj x := {|
    carrier := a ~> x : Type;
    is_setoid := homset a x : Setoid (a ~> x)
  |} : SetoidObject;
  fmap x y (f : x ~> y) := {|
    morphism (g : a ~> x) := f ∘ g : a ~> y
  |} : SetoidMorphism _ _
|}.
Notation "Hom( a , -)" := (Hom a) (format "Hom( a ,  -)").
```

- Hom(-, a) : C^op ⟶ **Sets**
  - fobj 把对象 x : C 映射为态射集 x ~> a
  - fmap 把态射 f : x ~> y 映射为态射集间的函数 (y ~> a) → (x ~> a), 由 (λ g : y ~> a, g ∘ f) 给出

```Coq
Program Definition CoHom {C : Category} (a : C) : C^op ⟶ Sets := {|
  fobj x := {|
    carrier := a ~{C^op}~> x : Type;
    is_setoid := @homset (C^op) a x : Setoid (a ~{C^op}~> x)
  |} : SetoidObject;
  fmap x y (f : x ~{C^op}~> y) := {|
    morphism (g : a ~{C^op}~> x) := f ∘ g : a ~{C^op}~> y
  |} : SetoidMorphism _ _
|}.
Notation "Hom(-, a )" := (CoHom a) (format "Hom(-,  a )").
```

## 米田引理


